#version 330 core

// Per-fragment data.
in vec2 UV;

// Per-instance data (same as per-call for now since we're not using instancing).
uniform float alpha;

// Per-call data.
uniform sampler2D textureSampler0;

// MIP bias.
uniform float mip;

out vec4 colour;

void main(){

	vec4 fragColour = texture(textureSampler0, UV, mip).rgba;
	
	if(fragColour.a == 0.f){
	
		discard;
	
	// Negative alpha values indicate dithering.
	}else if(alpha < 0.f){
	
		// 4x4 Bayer ordered dithering matrix.
		// Each element represents an alpha threshold.
		const mat4 ditherMatrix = mat4(
			vec4(-1.f/17.f,  -9.f/17.f,  -3.f/17.f,  -11.f/17.f),
			vec4(-13.f/17.f, -5.f/17.f,  -15.f/17.f, -7.f/17.f),
			vec4(-4.f/17.f,  -12.f/17.f, -2.f/17.f,  -10.f/17.f),
			vec4(-16.f/17.f, -8.f/17.f,  -14.f/17.f, -6.f/17.f)
		);
		vec4 ditherRow;
		float ditherThreshold;
		
		// Determine which row of the dither matrix to use.
		switch(int(gl_FragCoord.x) % 4){
			case 0:
				ditherRow = ditherMatrix[0];
			break;
			case 1:
				ditherRow = ditherMatrix[1];
			break;
			case 2:
				ditherRow = ditherMatrix[2];
			break;
			default:
				ditherRow = ditherMatrix[3];
		}
		// Now find the column and get the threshold value.
		switch(int(gl_FragCoord.y) % 4){
			case 0:
				ditherThreshold = ditherRow[0];
			break;
			case 1:
				ditherThreshold = ditherRow[1];
			break;
			case 2:
				ditherThreshold = ditherRow[2];
			break;
			default:
				ditherThreshold = ditherRow[3];
		}
			
		// If the fragment is below the alpha threshold, discard it.
		if(fragColour.a*alpha > ditherThreshold){
			discard;
		}else{
			fragColour.a = 1.f;
		}
		
	}else{
		fragColour.a *= alpha;
	}
	
	colour = fragColour;
	
}